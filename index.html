<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tetris</title>
<style>
  :root {
    --bg: #121725;
    --grid: #1e2233;
    --cell: 28px;
    --gap: 1px;

    --T: #b36be0; --O: #f7d041; --I: #30c3ec;
    --S: #5ccd6a; --Z: #ef5959; --L: #f69c3c; --J: #5185f7;
  }

  body {
    margin: 0;
    font-family: 'Segoe UI', sans-serif;
    background: var(--bg);
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }

  h1 {
    margin: 14px 0 4px;
    font-size: 1.8rem;
  }

  #wrapper {
    display: flex;
    gap: 18px;
    margin-top: 6px;
  }

  #board {
    display: grid;
    gap: var(--gap);
    background: var(--grid);
    grid-template-columns: repeat(10, var(--cell));
    grid-template-rows: repeat(20, var(--cell));
    border-radius: 8px;
    border: 3px solid #333;
  }

  .cell {
    width: var(--cell);
    height: var(--cell);
    background: #151a28;
    border-radius: 3px;
  }

  /* Î∏îÎ°ù ÏÉâÏÉÅ */
  .T { background: var(--T); }
  .O { background: var(--O); }
  .I { background: var(--I); }
  .S { background: var(--S); }
  .Z { background: var(--Z); }
  .L { background: var(--L); }
  .J { background: var(--J); }

  .active {
    outline: 1px solid #fff;
  }

  .ghost {
    opacity: 0.3;
  }

  #side {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .panel {
    background: #1b2031;
    border-radius: 8px;
    padding: 8px 10px;
    min-width: 100px;
  }

  .panel h3 {
    margin: 0 0 4px;
    font-size: 0.9rem;
  }

  #next, #hold {
    display: grid;
    grid-template-columns: repeat(4, 20px);
    grid-template-rows: repeat(4, 20px);
    gap: 1px;
    background: var(--grid);
    border-radius: 6px;
  }

  #next div, #hold div {
    background: #151a28;
    border-radius: 3px;
    width: 20px;
    height: 20px;
  }

  #start {
    padding: 10px 18px;
    border: none;
    border-radius: 6px;
    background: #4caf50;
    color: #fff;
    cursor: pointer;
    font-size: 1rem;
    margin-top: 8px;
    user-select: none;
  }

  #controls {
    display: grid;
    grid-template-columns: repeat(3, 60px);
    grid-template-rows: repeat(2, 60px);
    gap: 8px;
    margin: 14px 0;
    user-select: none;
    touch-action: manipulation;
  }

  .btn {
    background: #333;
    border: 2px solid #555;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    color: #fff;
    cursor: pointer;
  }

  .btn:active {
    background: #555;
  }

  @media (max-width: 480px) {
    :root {
      --cell: 22px;
    }

    #next, #hold {
      grid-template-columns: repeat(4, 16px);
      grid-template-rows: repeat(4, 16px);
    }

    #next div, #hold div {
      width: 16px;
      height: 16px;
    }

    #controls {
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(2, 50px);
      gap: 6px;
    }
  }
</style>
</head>
<body>
  </h1>Classic Tetris</h1>
  <button id="start">Í≤åÏûÑ ÏãúÏûë</button>

  <div id="wrapper" style="display:none;">
    <div id="board"></div>

    <div id="side">
      <div class="panel">
        <h3>Îã§Ïùå</h3>
        <div id="next"></div>
      </div>
      <div class="panel">
        <h3>Î≥¥Î•ò</h3>
        <div id="hold"></div>
      </div>
      <div class="panel">
        <h3>Ï†êÏàò</h3>
        <div id="score">0</div>
      </div>
      <div class="panel">
        <h3>Î†àÎ≤®</h3>
        <div id="level">1</div>
      </div>
      <div class="panel">
        <h3>Ï§Ñ</h3>
        <div id="lines">0</div>
      </div>
    </div>
  </div>

  <div id="controls" style="display:none;">
    <div class="btn" id="left">‚¨ÖÔ∏è</div>
    <div class="btn" id="rotate">üîÑ</div>
    <div class="btn" id="right">‚û°Ô∏è</div>
    <div class="btn" style="grid-column: 2/3" id="down">‚¨áÔ∏è</div>
    <div class="btn" style="grid-column: 2/3" id="drop">üß®</div>
    <div class="btn" id="holdBtn">‚è∏Ô∏è</div>
  </div>

<script>
(() => {
  const ROWS = 20;
  const COLS = 10;

  const boardEl = document.getElementById('board');
  const nextEl = document.getElementById('next');
  const holdEl = document.getElementById('hold');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const startBtn = document.getElementById('start');
  const wrapper = document.getElementById('wrapper');
  const controls = document.getElementById('controls');

  const leftBtn = document.getElementById('left');
  const rightBtn = document.getElementById('right');
  const downBtn = document.getElementById('down');
  const rotateBtn = document.getElementById('rotate');
  const dropBtn = document.getElementById('drop');
  const holdBtn = document.getElementById('holdBtn');

  // Î∏îÎ°ù Î™®Ïñë (ÌöåÏ†ÑÎ≥Ñ Ïò§ÌîÑÏÖã)
  const SHAPES = {
    I: [
      [0,1,2,3],
      [0,COLS,COLS*2,COLS*3]
    ],
    O: [
      [0,1,COLS,COLS+1]
    ],
    T: [
      [1,COLS,COLS+1,COLS+2],
      [1,COLS+1,COLS+2,COLS*2+1],
      [COLS,COLS+1,COLS+2,COLS*2+1],
      [1,COLS,COLS+1,COLS*2+1]
    ],
    S: [
      [1,2,COLS,COLS+1],
      [0,COLS,COLS+1,COLS*2+1]
    ],
    Z: [
      [0,1,COLS+1,COLS+2],
      [2,COLS+1,COLS+2,COLS*2+1]
    ],
    J: [
      [0,COLS,COLS+1,COLS+2],
      [1,2,COLS+1,COLS*2+1],
      [COLS,COLS+1,COLS+2,COLS*2+2],
      [1,COLS+1,COLS*2,COLS*2+1]
    ],
    L: [
      [2,COLS,COLS+1,COLS+2],
      [1,COLS+1,COLS*2+1,COLS*2+2],
      [COLS,COLS+1,COLS+2,COLS*2],
      [0,1,COLS+1,COLS*2+1]
    ]
  };

  const COLORS = {
    I: 'I',
    O: 'O',
    T: 'T',
    S: 'S',
    Z: 'Z',
    J: 'J',
    L: 'L'
  };

  let board = [];
  let current = null;
  let nextQueue = [];
  let holdPiece = null;
  let canHold = true;

  let score = 0;
  let level = 1;
  let linesCleared = 0;

  let playing = false;
  let dropInterval = 1000;
  let dropTimer = null;

  function createBoard() {
    board = Array(ROWS * COLS).fill(0);
  }

  function randomBlock() {
    const types = Object.keys(SHAPES);
    return types[Math.floor(Math.random() * types.length)];
  }

  function refillQueue() {
    while(nextQueue.length < 5) {
      nextQueue.push(randomBlock());
    }
    drawMini(nextEl, nextQueue[0]);
  }

  function drawBoard() {
    boardEl.innerHTML = '';
    for(let i=0; i < ROWS * COLS; i++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      const val = board[i];
      if(val && COLORS[val]) {
        cell.classList.add(COLORS[val]);
      }
      boardEl.appendChild(cell);
    }
  }

  function drawMini(el, type) {
    el.innerHTML = '';
    for(let i=0; i<16; i++) {
      const c = document.createElement('div');
      c.classList.add('cell');
      el.appendChild(c);
    }
    if (!type) return;
    const shape = SHAPES[type][0];
    shape.forEach(pos => {
      const cell = el.children[pos];
      if(cell) cell.classList.add(COLORS[type]);
    });
  }

  function getCurrentPositions() {
    const shapeArr = SHAPES[current.type][current.rotation];
    return shapeArr.map(offset => current.pos + offset);
  }

  function isCollision(pos, type, rotation) {
    const shapeArr = SHAPES[type][rotation];
    for(let offset of shapeArr) {
      const idx = pos + offset;
      const x = idx % COLS;
      const y = Math.floor(idx / COLS);

      if (x < 0 || x >= COLS || y >= ROWS) return true;
      if (y < 0) continue;

      if (board[idx] !== 0) return true;
    }
    return false;
  }

  function drawCurrent() {
    drawBoard();
    const positions = getCurrentPositions();
    const cells = boardEl.children;

    // Í≥†Ïä§Ìä∏ ÏúÑÏπò Í∑∏Î¶¨Í∏∞
    const ghostPos = findGhostPos();
    if(ghostPos !== null) {
      const ghostShape = SHAPES[current.type][current.rotation];
      ghostShape.forEach(offset => {
        const idx = ghostPos + offset;
        if (idx >= 0 && idx < board.length) {
          cells[idx].classList.add('ghost', COLORS[current.type]);
        }
      });
    }

    // ÌòÑÏû¨ Î∏îÎ°ù Í∑∏Î¶¨Í∏∞
    positions.forEach(idx => {
      if(idx >= 0 && idx < board.length) {
        cells[idx].classList.add('active', COLORS[current.type]);
      }
    });
  }

  function findGhostPos() {
    let pos = current.pos;
    while(!isCollision(pos + COLS, current.type, current.rotation)) {
      pos += COLS;
    }
    return pos;
  }

  function fixCurrent() {
    const positions = getCurrentPositions();
    positions.forEach(idx => {
      if(idx >= 0 && idx < board.length) {
        board[idx] = current.type;
      }
    });
  }

  function clearLines() {
    let linesRemoved = 0;
    for(let row = ROWS-1; row >= 0; row--) {
      let isFull = true;
      for(let col = 0; col < COLS; col++) {
        if(board[row * COLS + col] === 0) {
          isFull = false;
          break;
        }
      }
      if(isFull) {
        for(let r = row; r > 0; r--) {
          for(let c = 0; c < COLS; c++) {
            board[r * COLS + c] = board[(r-1)*COLS + c];
          }
        }
        for(let c=0; c < COLS; c++) {
          board[c] = 0;
        }
        linesRemoved++;
        row++;
      }
    }
    if(linesRemoved > 0) {
      linesCleared += linesRemoved;
      const pointsMap = [0, 100, 300, 500, 800];
      score += pointsMap[linesRemoved] * level;
      if(linesCleared >= level * 10) {
        level++;
        setDropInterval();
      }
      updateHUD();
    }
  }

  function updateHUD() {
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = linesCleared;
  }

  function newPiece() {
    current = {
      type: nextQueue.shift(),
      rotation: 0,
      pos: 3
    };
    refillQueue();
    canHold = true;

    if(isCollision(current.pos, current.type, current.rotation)) {
      gameOver();
      return;
    }
    drawCurrent();
  }

  function setDropInterval() {
    if(dropTimer) clearInterval(dropTimer);
    dropInterval = Math.max(100, 1000 - (level - 1) * 100);
    dropTimer = setInterval(() => {
      dropDown();
    }, dropInterval);
  }

  function dropDown() {
    if(!isCollision(current.pos + COLS, current.type, current.rotation)) {
      current.pos += COLS;
      drawCurrent();
    } else {
      fixCurrent();
      clearLines();
      newPiece();
    }
  }

  function hardDrop() {
    while(!isCollision(current.pos + COLS, current.type, current.rotation)) {
      current.pos += COLS;
      score++;
    }
    fixCurrent();
    clearLines();
    newPiece();
    drawCurrent();
  }

  function moveLeft() {
    if(!isCollision(current.pos -1, current.type, current.rotation)) {
      current.pos--;
      drawCurrent();
    }
  }
  function moveRight() {
    if(!isCollision(current.pos +1, current.type, current.rotation)) {
      current.pos++;
      drawCurrent();
    }
  }

  function rotate() {
    const newRot = (current.rotation + 1) % SHAPES[current.type].length;
    if(!isCollision(current.pos, current.type, newRot)) {
      current.rotation = newRot;
      drawCurrent();
    } else {
      for(let kick of [-1,1,-2,2]) {
        if(!isCollision(current.pos + kick, current.type, newRot)) {
          current.pos += kick;
          current.rotation = newRot;
          drawCurrent();
          break;
        }
      }
    }
  }

  function hold() {
    if(!canHold) return;
    if(holdPiece === null) {
      holdPiece = current.type;
      newPiece();
    } else {
      let temp = current.type;
      current.type = holdPiece;
      holdPiece = temp;
      current.pos = 3;
      current.rotation = 0;
      if(isCollision(current.pos, current.type, current.rotation)) {
        gameOver();
        return;
      }
      drawCurrent();
    }
    canHold = false;
    drawMini(holdEl, holdPiece);
  }

  function gameOver() {
    playing = false;
    clearInterval(dropTimer);
    alert(`Í≤åÏûÑ Ïò§Î≤Ñ!\nÏµúÏ¢Ö Ï†êÏàò: ${score}`);
    startBtn.style.display = 'inline-block';
    wrapper.style.display = 'none';
    controls.style.display = 'none';
  }

  function startGame() {
    createBoard();
    nextQueue = [];
    refillQueue();
    holdPiece = null;
    canHold = true;
    score = 0;
    level = 1;
    linesCleared = 0;
    updateHUD();
    startBtn.style.display = 'none';
    wrapper.style.display = 'flex';
    controls.style.display = 'grid';
    drawMini(holdEl, null);
    newPiece();
    setDropInterval();
    playing = true;
  }

  // ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏
  document.addEventListener('keydown', e => {
    if(!playing) return;
    switch(e.key) {
      case 'ArrowLeft': moveLeft(); break;
      case 'ArrowRight': moveRight(); break;
      case 'ArrowDown': dropDown(); break;
      case 'ArrowUp': rotate(); break;
      case ' ': hardDrop(); break;
      case 'Shift': hold(); break;
    }
  });

  // Î™®Î∞îÏùº Î≤ÑÌäº Ïù¥Î≤§Ìä∏
  leftBtn.addEventListener('click', moveLeft);
  rightBtn.addEventListener('click', moveRight);
  downBtn.addEventListener('click', dropDown);
  rotateBtn.addEventListener('click', rotate);
  dropBtn.addEventListener('click', hardDrop);
  holdBtn.addEventListener('click', hold);

  startBtn.addEventListener('click', startGame);

})();
</script>

</body>
</html>
