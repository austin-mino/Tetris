<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tetris</title>
<style>
  :root {
    --bg: #121725;
    --grid: #1e2233;
    --cell-size: 28px;
    --gap: 2px;

    --T: #b36be0;
    --O: #f7d041;
    --I: #30c3ec;
    --S: #5ccd6a;
    --Z: #ef5959;
    --L: #f69c3c;
    --J: #5185f7;
  }
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--bg);
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
  }
  h1 {
    margin: 20px 0 10px;
    font-weight: 700;
  }
  #game {
    display: grid;
    grid-template-columns: repeat(10, var(--cell-size));
    grid-template-rows: repeat(20, var(--cell-size));
    gap: var(--gap);
    background: var(--grid);
    border: 3px solid #333;
    border-radius: 6px;
    user-select: none;
  }
  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    background: #151a28;
    border-radius: 4px;
  }
  .T { background: var(--T); }
  .O { background: var(--O); }
  .I { background: var(--I); }
  .S { background: var(--S); }
  .Z { background: var(--Z); }
  .L { background: var(--L); }
  .J { background: var(--J); }
  .ghost {
    opacity: 0.3;
  }
  #info {
    margin-top: 15px;
    display: flex;
    gap: 20px;
    font-size: 16px;
  }
  #info > div {
    min-width: 80px;
    text-align: center;
  }
  button {
    margin-top: 15px;
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 8px;
    background: #4caf50;
    color: white;
    cursor: pointer;
    user-select: none;
  }
  button:active {
    background: #388e3c;
  }
  #controls {
    margin-top: 15px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .btn {
    width: 50px;
    height: 50px;
    background: #333;
    border-radius: 8px;
    color: white;
    font-size: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    user-select: none;
    cursor: pointer;
  }
  .btn:active {
    background: #555;
  }

  @media (max-width: 480px) {
    :root {
      --cell-size: 22px;
    }
    #controls .btn {
      width: 44px;
      height: 44px;
      font-size: 20px;
    }
  }
</style>
</head>
<body>
  <h1>Tetris</h1>
  <div id="game"></div>
  <div id="info">
    <div>Ï†êÏàò<br><span id="score">0</span></div>
    <div>Î†àÎ≤®<br><span id="level">1</span></div>
    <div>Ï§Ñ<br><span id="lines">0</span></div>
  </div>
  <button id="startBtn">Í≤åÏûÑ ÏãúÏûë</button>

  <div id="controls" style="display:none;">
    <div class="btn" id="leftBtn">‚¨ÖÔ∏è</div>
    <div class="btn" id="rotateBtn">üîÑ</div>
    <div class="btn" id="rightBtn">‚û°Ô∏è</div>
    <div class="btn" id="downBtn">‚¨áÔ∏è</div>
    <div class="btn" id="dropBtn">‚è¨</div>
    <div class="btn" id="holdBtn">‚è∏Ô∏è</div>
  </div>

<script>
(() => {
  const ROWS = 20;
  const COLS = 10;
  const game = document.getElementById('game');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const startBtn = document.getElementById('startBtn');
  const controls = document.getElementById('controls');

  // ÌÖåÌä∏Î¶¨Ïä§ Î∏îÎ°ù Î™®Ïñë (4x4 matrix)
  const SHAPES = {
    I: [
      [
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0]
      ],
      [
        [0,0,1,0],
        [0,0,1,0],
        [0,0,1,0],
        [0,0,1,0]
      ]
    ],
    J: [
      [
        [1,0,0],
        [1,1,1],
        [0,0,0]
      ],
      [
        [0,1,1],
        [0,1,0],
        [0,1,0]
      ],
      [
        [0,0,0],
        [1,1,1],
        [0,0,1]
      ],
      [
        [0,1,0],
        [0,1,0],
        [1,1,0]
      ],
    ],
    L: [
      [
        [0,0,1],
        [1,1,1],
        [0,0,0]
      ],
      [
        [0,1,0],
        [0,1,0],
        [0,1,1]
      ],
      [
        [0,0,0],
        [1,1,1],
        [1,0,0]
      ],
      [
        [1,1,0],
        [0,1,0],
        [0,1,0]
      ]
    ],
    O: [
      [
        [1,1],
        [1,1]
      ]
    ],
    S: [
      [
        [0,1,1],
        [1,1,0],
        [0,0,0]
      ],
      [
        [0,1,0],
        [0,1,1],
        [0,0,1]
      ]
    ],
    Z: [
      [
        [1,1,0],
        [0,1,1],
        [0,0,0]
      ],
      [
        [0,0,1],
        [0,1,1],
        [0,1,0]
      ]
    ],
    T: [
      [
        [0,1,0],
        [1,1,1],
        [0,0,0]
      ],
      [
        [0,1,0],
        [0,1,1],
        [0,1,0]
      ],
      [
        [0,0,0],
        [1,1,1],
        [0,1,0]
      ],
      [
        [0,1,0],
        [1,1,0],
        [0,1,0]
      ]
    ]
  };

  const COLORS = {
    I: 'I', J: 'J', L: 'L', O: 'O', S: 'S', Z: 'Z', T: 'T'
  };

  let board = [];
  let currentPiece = null;
  let currentPos = {x: 0, y: 0};
  let currentRotation = 0;
  let score = 0;
  let level = 1;
  let lines = 0;
  let dropInterval = 1000;
  let dropTimer = null;
  let holdPiece = null;
  let canHold = true;

  function createBoard() {
    board = [];
    for(let r=0; r<ROWS; r++) {
      const row = new Array(COLS).fill(0);
      board.push(row);
    }
  }

  function drawBoard() {
    game.innerHTML = '';
    for(let r=0; r<ROWS; r++) {
      for(let c=0; c<COLS; c++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        if(board[r][c] !== 0) {
          cell.classList.add(COLORS[board[r][c]]);
        }
        game.appendChild(cell);
      }
    }
  }

  function getCurrentShape() {
    return SHAPES[currentPiece][currentRotation];
  }

  function drawCurrentPiece() {
    const shape = getCurrentShape();
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const x = currentPos.x + c;
          const y = currentPos.y + r;
          if(y >= 0 && y < ROWS && x >=0 && x < COLS) {
            const idx = y * COLS + x;
            game.children[idx].classList.add(COLORS[currentPiece]);
          }
        }
      }
    }
  }

  function collision(xOffset=0, yOffset=0, rotation=null) {
    const shape = SHAPES[currentPiece][rotation === null ? currentRotation : rotation];
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const x = currentPos.x + c + xOffset;
          const y = currentPos.y + r + yOffset;
          if(x < 0 || x >= COLS || y >= ROWS) return true;
          if(y >= 0 && board[y][x] !== 0) return true;
        }
      }
    }
    return false;
  }

  function placePiece() {
    const shape = getCurrentShape();
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[r].length; c++) {
        if(shape[r][c]) {
          const x = currentPos.x + c;
          const y = currentPos.y + r;
          if(y >= 0 && y < ROWS && x >= 0 && x < COLS) {
            board[y][x] = currentPiece;
          }
        }
      }
    }
  }

  function clearLines() {
    let cleared = 0;
    for(let r=ROWS-1; r>=0; r--) {
      if(board[r].every(cell => cell !== 0)) {
        board.splice(r, 1);
        board.unshift(new Array(COLS).fill(0));
        cleared++;
        r++; // Îã§Ïãú Ï≤¥ÌÅ¨
      }
    }
    if(cleared > 0) {
      lines += cleared;
      score += [0,100,300,500,800][cleared] * level;
      if(lines >= level * 10) {
        level++;
        dropInterval = Math.max(100, dropInterval - 100);
        clearInterval(dropTimer);
        dropTimer = setInterval(dropPiece, dropInterval);
      }
      updateInfo();
    }
  }

  function updateInfo() {
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = lines;
  }

  function spawnPiece() {
    const pieces = Object.keys(SHAPES);
    currentPiece = pieces[Math.floor(Math.random() * pieces.length)];
    currentRotation = 0;
    currentPos = {x: Math.floor(COLS / 2) - 2, y: -2};
    canHold = true;
    if(collision(0,0,currentRotation)) {
      gameOver();
    }
  }

  function movePiece(dx, dy) {
    if(!collision(dx, dy)) {
      currentPos.x += dx;
      currentPos.y += dy;
      return true;
    }
    return false;
  }

  function rotatePiece() {
    const nextRotation = (currentRotation + 1) % SHAPES[currentPiece].length;
    if(!collision(0,0,nextRotation)) {
      currentRotation = nextRotation;
      return;
    }
    // Î≤ΩÌÇ• ÏãúÎèÑ (ÏôºÏ™Ω, Ïò§Î•∏Ï™Ω)
    if(!collision(-1, 0, nextRotation)) {
      currentPos.x--;
      currentRotation = nextRotation;
      return;
    }
    if(!collision(1, 0, nextRotation)) {
      currentPos.x++;
      currentRotation = nextRotation;
      return;
    }
  }

  function dropPiece() {
    if(!movePiece(0,1)) {
      placePiece();
      clearLines();
      spawnPiece();
    }
    render();
  }

  function hardDrop() {
    while(movePiece(0,1)) {
      score += 2;
    }
    placePiece();
    clearLines();
    spawnPiece();
    updateInfo();
    render();
  }

  function holdCurrent() {
    if(!canHold) return;
    if(holdPiece === null) {
      holdPiece = currentPiece;
      spawnPiece();
    } else {
      [holdPiece, currentPiece] = [currentPiece, holdPiece];
      currentRotation = 0;
      currentPos = {x: Math.floor(COLS / 2) - 2, y: -2};
      if(collision(0,0,currentRotation)) {
        gameOver();
      }
    }
    canHold = false;
    render();
  }

  function gameOver() {
    clearInterval(dropTimer);
    alert(`Í≤åÏûÑ Ïò§Î≤Ñ! Ï†êÏàò: ${score}`);
    startBtn.style.display = 'block';
    controls.style.display = 'none';
  }

  function render() {
    drawBoard();
    drawCurrentPiece();
  }

  function startGame() {
    createBoard();
    score = 0;
    level = 1;
    lines = 0;
    dropInterval = 1000;
    updateInfo();
    spawnPiece();
    render();
    startBtn.style.display = 'none';
    controls.style.display = 'flex';

    if(dropTimer) clearInterval(dropTimer);
    dropTimer = setInterval(dropPiece, dropInterval);
  }

  // ÌÇ§Î≥¥Îìú ÏûÖÎ†• Ï≤òÎ¶¨
  document.addEventListener('keydown', e => {
    if(startBtn.style.display !== 'none') return; // Í≤åÏûÑÏ§ë ÏïÑÎãàÎ©¥ Î¨¥Ïãú

    switch(e.key) {
      case 'ArrowLeft':
        movePiece(-1, 0);
        render();
        break;
      case 'ArrowRight':
        movePiece(1, 0);
        render();
        break;
      case 'ArrowDown':
        movePiece(0,1);
        score++;
        updateInfo();
        render();
        break;
      case 'ArrowUp':
        rotatePiece();
        render();
        break;
      case ' ':
        e.preventDefault();
        hardDrop();
        break;
      case 'c':
      case 'C':
        holdCurrent();
        break;
    }
  });

  // Î≤ÑÌäº ÏûÖÎ†• Ï≤òÎ¶¨
  function bindBtn(id, fn) {
    const btn = document.getElementById(id);
    btn.addEventListener('click', () => {
      if(startBtn.style.display !== 'none' && id !== 'startBtn') return;
      fn();
    });
  }
  bindBtn('leftBtn', () => { movePiece(-1, 0); render(); });
  bindBtn('rightBtn', () => { movePiece(1, 0); render(); });
  bindBtn('downBtn', () => { movePiece(0,1); score++; updateInfo(); render(); });
  bindBtn('rotateBtn', () => { rotatePiece(); render(); });
  bindBtn('dropBtn', () => { hardDrop(); });
  bindBtn('holdBtn', () => { holdCurrent(); });

  startBtn.addEventListener('click', startGame);
})();
</script>
</body>
</html>
