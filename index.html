<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>🎮 Classic Tetris</title>

  <style>
    :root{
      --bg:#121725;        /* 배경  */
      --grid:#1e2233;      /* 보드 배경 */
      --cell:28px;         /* 셀 한 변 */
      --gap:1px;

      /* 블록 색상 */
      --T:#b36be0; --O:#f7d041; --I:#30c3ec;
      --S:#5ccd6a; --Z:#ef5959; --L:#f69c3c; --J:#5185f7;
    }
    body{
      margin:0; font-family:'Segoe UI',sans-serif;
      background:var(--bg); color:#fff;
      display:flex; flex-direction:column; align-items:center;
      -webkit-tap-highlight-color:transparent; touch-action:manipulation;
    }
    h1{margin:14px 0 4px;font-size:1.8rem}
    #wrapper{display:flex;gap:18px;margin-top:6px}

    /* ─── 보드 기본 ─── */
    #board{display:grid;gap:var(--gap);background:var(--grid);touch-action:none}
    .cell{width:var(--cell);height:var(--cell);background:#151a28}
    /* 고정 블록 색 */
    .T{background:var(--T)} .O{background:var(--O)} .I{background:var(--I)}
    .S{background:var(--S)} .Z{background:var(--Z)} .L{background:var(--L)} .J{background:var(--J)}
    /* 현재 블록 테두리 */
    .active{outline:1px solid #fff}
    /* 고스트 블록은 잔상 X, 흐림 O */
    .ghost{background:rgba(255,255,255,.18)}

    /* ─── 사이드 패널 ─── */
    #side{display:flex;flex-direction:column;gap:10px}
    .panel{background:#1b2031;border-radius:8px;padding:8px 10px;min-width:100px}
    .panel h3{margin:0 0 4px;font-size:.9rem}
    .mini{
      display:grid;grid-template-columns:repeat(4,18px);
      grid-template-rows:repeat(4,18px);gap:1px;background:var(--grid)
    }
    .mini div{width:18px;height:18px;background:#151a28}

    /* ─── 터치 컨트롤 ─── */
    #controls{
      display:grid;grid-template-columns:repeat(3,60px);
      grid-template-rows:repeat(2,60px);gap:8px;margin:14px 0;
      user-select:none
    }
    .btn{
      background:#333;border:2px solid #555;border-radius:8px;
      display:flex;align-items:center;justify-content:center;
      font-size:1.4rem;color:#fff
    }
    .btn:active{background:#555}

    /* 시작 버튼 */
    #start{
      padding:8px 18px;border:none;border-radius:6px;
      background:#4caf50;color:#fff;cursor:pointer;font-size:1rem;margin-top:8px
    }

    /* 모바일 보드 축소 */
    @media(max-width:480px){
      :root{--cell:22px}
      .mini{grid-template-columns:repeat(4,14px);grid-template-rows:repeat(4,14px)}
      #controls{grid-template-columns:repeat(3,50px);grid-template-rows:repeat(2,50px)}
    }
  </style>
</head>
<body>
  <h1>🎮 Classic Tetris</h1>
  <button id="start">게임 시작</button>

  <div id="wrapper" style="display:none">
    <div id="board"></div>

    <div id="side">
      <div class="panel"><h3>다음</h3><div id="next"  class="mini"></div></div>
      <div class="panel"><h3>보류</h3><div id="hold"  class="mini"></div></div>
      <div class="panel"><h3>점수</h3><div id="score">0</div></div>
      <div class="panel"><h3>레벨</h3><div id="level">1</div></div>
      <div class="panel"><h3>줄</h3><div id="lines">0</div></div>
    </div>
  </div>

  <div id="controls" style="display:none">
    <div class="btn" id="left">⬅️</div>
    <div class="btn" id="rotate">🔄</div>
    <div class="btn" id="right">➡️</div>
    <div class="btn" style="grid-column:2/3" id="down">⬇️</div>
    <div class="btn" style="grid-column:2/3" id="drop">🧨</div>
    <div class="btn" id="holdBtn">⏸️</div>
  </div><script>
const rows = 20, cols = 10, board = $('#board');
let grid = [], queue = [], current = null;
let holdPiece = null, canHold = true;
let playing = false;
let score = 0, level = 1, lines = 0;

const baseInterval = 700, lockDelay = 500;
let timer = null, lockTimer = 0;

function $(id){ return document.getElementById(id); }

/* === 도형(SRS 4-방향) === */
const SHAPES = {
  T: [[1,cols,cols+1,cols+2],[1,cols+1,cols+2,cols*2+1],[cols,cols+1,cols+2,cols*2+1],[1,cols,cols+1,cols*2+1]],
  O: [[0,1,cols,cols+1]],
  I: [[1,cols+1,cols*2+1,cols*3+1],[cols,cols+1,cols+2,cols+3]],
  S: [[1,2,cols,cols+1],[0,cols,cols+1,cols*2]],
  Z: [[0,1,cols+1,cols+2],[2,cols,cols+1,cols*2+1]],
  L: [[0,cols,cols*2,cols*2+1],[cols,cols+1,cols+2,2],[0,1,cols+1,cols*2+1],[cols,cols*2,cols*2+1,cols*2+2]],
  J: [[1,cols+1,cols*2+1,cols*2],[0,1,2,cols+2],[1,cols+1,cols*2+1,cols*2+2],[0,cols,cols+1,cols+2]]
};
const COLORS = {T:'T',O:'O',I:'I',S:'S',Z:'Z',L:'L',J:'J'};

/* 현재 블록 shape() 메서드 */
Object.defineProperty(Object.prototype,'shape',{
  value(){ return SHAPES[this.name][this.rot]; }, enumerable:false
});

/* === 보드 생성 === */
function buildGrid(){
  board.style.gridTemplateColumns = `repeat(${cols},var(--cell))`;
  board.style.gridTemplateRows    = `repeat(${rows},var(--cell))`;
  board.innerHTML = ''; grid = [];
  for(let i=0;i<rows*cols;i++){
    const d = document.createElement('div'); d.className='cell';
    board.appendChild(d); grid.push(d);
  }
}

/* === 미니 보드 === */
function drawMini(el,piece){
  el.innerHTML=''; const cells=[];
  for(let i=0;i<16;i++){ const d=document.createElement('div'); d.className='cell'; el.appendChild(d); cells.push(d);}
  if(!piece) return;
  SHAPES[piece][0].forEach(i=>{
    const x=i%cols, y=Math.floor(i/cols);
    cells[y*4+x].classList.add(COLORS[piece]);
  });
}

/* === HUD === */
function hud(){ 
  $('#score').textContent=score; 
  $('#level').textContent=level; 
  $('#lines').textContent=lines; 
}

/* === 큐 관리 === */
function rnd(){ return Object.keys(SHAPES)[Math.floor(Math.random()*7)]; }
function refill(){ 
  while(queue.length<5) queue.push(rnd()); 
  drawMini($('#next'),queue[0]); 
}

/* === 충돌 검사 === */
function hit(shape,off=0){
  return shape.some(i=>{
    const ni=current.pos+off+i;
    if(ni < 0) return true;  // 음수 인덱스 처리
    const x=ni%cols, y=Math.floor(ni/cols);
    return x<0||x>=cols||y>=rows||grid[ni].classList.contains('frozen');
  });
}

/* 낙하 거리 계산 */
function dropDist(){ 
  let d=0; 
  while(!hit(current.shape(),(d+1)*cols)) d++; 
  return d; 
}

/* === 그리기 === */
function clearGhost(){ grid.forEach(c=>c.classList.remove('ghost')); }
function drawCells(idxs,cls,color){ idxs.forEach(i=>grid[i]?.classList.add(cls,color)); }
function eraseCells(idxs,color){ idxs.forEach(i=>grid[i]?.classList.remove('active',color)); }

function drawCurr(){
  drawCells(current.shape().map(i=>current.pos+i),'active',COLORS[current.name]);
  placeGhost();
}
function eraseCurr(){
  eraseCells(current.shape().map(i=>current.pos+i),COLORS[current.name]);
  clearGhost();
}
function placeGhost(){
  clearGhost();
  const d=dropDist();
  current.shape().forEach(i=>grid[current.pos+i+d*cols]?.classList.add('ghost'));
}/* === 블록 === */
function newPiece(){
  current={name:queue.shift(),pos:3,rot:0};
  refill(); canHold=true;
  if(hit(current.shape())) return gameOver();
  drawCurr();
}

function lockPiece(){
  eraseCurr();
  current.shape().forEach(i=>grid[current.pos+i].classList.add('frozen',COLORS[current.name]));
  clearGhost(); 
  delLines(); 
  newPiece(); 
  setGravity();
}

/* === 라인 삭제 & 점수 === */
function delLines(){
  let cleared=0;
  for(let r=rows-1;r>=0;r--){
    if([...Array(cols)].every(c=>grid[r*cols+c].classList.contains('frozen'))){
      cleared++;
      for(let c=0;c<cols;c++) grid[r*cols+c].className='cell';
      // 줄 삭제 후 블록 내려오기 (클래스만 복사)
      for(let rr=r; rr>0; rr--){
        for(let cc=0; cc<cols; cc++){
          const aboveCell = grid[(rr-1)*cols+cc];
          const currCell = grid[rr*cols+cc];
          currCell.className = aboveCell.className;
        }
      }
      for(let c=0;c<cols;c++) grid[c].className='cell';
      r++;
    }
  }
  if(cleared){
    score += [0,100,300,500,800][cleared] * level;
    lines += cleared;
    if(lines >= level*10){ level++; setGravity(); }
    hud();
  }
}

/* === 이동 / 회전 === */
function move(dx,dy=0){
  eraseCurr();
  if(!hit(current.shape(),dx+dy*cols)){
    current.pos += dx+dy*cols;
    if(dy){ score++; hud(); }
    lockTimer=0;
  }
  drawCurr();
}

function rotate(){
  eraseCurr();
  const nxt=(current.rot+1)%SHAPES[current.name].length;
  for(const k of [0,-1,1,-2,2]){
    if(!hit(SHAPES[current.name][nxt],k)){
      current.rot=nxt; current.pos+=k; break;
    }
  }
  drawCurr();
}

function soft(){ move(0,1); }

function hard(){
  eraseCurr();
  const d=dropDist(); current.pos += d*cols; score += d*2;
  drawCurr(); lockPiece(); hud();
}

/* === 홀드 === */
function hold(){
  if(!canHold) return;
  eraseCurr(); clearGhost();
  if(!holdPiece){ 
    holdPiece=current.name; 
    newPiece(); 
  } else {
    [holdPiece,current.name]=[current.name,holdPiece];
    current.pos=3; current.rot=0;
    if(hit(current.shape())) return gameOver();
    drawCurr();
  }
  canHold=false; drawMini($('#hold'),holdPiece);
}

/* === 중력 & 타이머 === */
function setGravity(){
  clearInterval(timer);
  timer=setInterval(()=>{
    if(!lockTimer) soft();
    else if(Date.now()-lockTimer>lockDelay) lockPiece();
  }, Math.max(100, baseInterval-(level-1)*50));
}/* === 게임 컨트롤 === */
function startGame(){
  console.log('게임 시작!'); 
  if(playing) return;
  playing=true; 
  $('#start').style.display='none';
  $('#wrapper').style.display='flex'; 
  $('#controls').style.display='grid';
  score=level=lines=0; hud(); buildGrid(); queue=[]; refill();
  holdPiece=null; canHold=true; drawMini($('#hold'),null);
  newPiece(); setGravity();
}

function gameOver(){
  clearInterval(timer);
  alert(`게임 오버! 총 점수: ${score}`);
  playing=false;
  $('#wrapper').style.display='none'; 
  $('#controls').style.display='none';
  $('#start').style.display='block';
}

/* === 입력 === */
document.addEventListener('keydown',e=>{
  if(!playing) return;
  switch(e.key){
    case'ArrowLeft': e.preventDefault(); move(-1); break;
    case'ArrowRight': e.preventDefault(); move(1);  break;
    case'ArrowDown': e.preventDefault(); soft();   break;
    case'ArrowUp': e.preventDefault(); rotate(); break;
    case' ': e.preventDefault(); hard(); break;
    case'c':case'C':case'Shift': e.preventDefault(); hold(); break;
  }
});

[['left',()=>move(-1)],['right',()=>move(1)],['down',soft],
 ['rotate',rotate],['drop',hard],['holdBtn',hold]]
 .forEach(([id,fn])=>{
   const el = $('#'+id);
   if(!el) return;
   el.addEventListener('touchstart',e=>{
     e.preventDefault();
     fn();
   }, { passive:false });
 });/* === DOM 로드 후 초기화 === */
document.addEventListener('DOMContentLoaded', () => {
  $('#start').onclick = startGame;
});
</script>
</body>
</html>
