<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tetris</title>
  <style>
    :root {
      --bg: #121725;
      --grid: #1e2233;
      --cell: 28px;
      --gap: 1px;

      --T: #b36be0; --O: #f7d041; --I: #30c3ec;
      --S: #5ccd6a; --Z: #ef5959; --L: #f69c3c; --J: #5185f7;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: var(--bg);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    h1 { margin: 14px 0 4px; font-size: 1.8rem; }

    #wrapper { gap: 18px; margin-top: 6px; display: none; }

    #board { display: grid; gap: var(--gap); background: var(--grid); }

    .cell { width: var(--cell); height: var(--cell); background: #151a28; }

    .T { background: var(--T); } .O { background: var(--O); } .I { background: var(--I); }
    .S { background: var(--S); } .Z { background: var(--Z); } .L { background: var(--L); } .J { background: var(--J); }

    .active { outline: 1px solid #fff; }
    .ghost  { background: rgba(255,255,255,.18); }

    #side { display: flex; flex-direction: column; gap: 10px; }

    .panel {
      background: #1b2031;
      border-radius: 8px;
      padding: 8px 10px;
      min-width: 100px;
    }
    .panel h3 { margin: 0 0 4px; font-size: .9rem; }

    .mini {
      display: grid;
      grid-template-columns: repeat(4, 18px);
      grid-template-rows: repeat(4, 18px);
      gap: 1px;
      background: var(--grid);
    }
    .mini div { width: 18px; height: 18px; background: #151a28; }

    #controls {
      display: none;
      grid-template-columns: repeat(3, 60px);
      grid-template-rows: repeat(2, 60px);
      gap: 8px;
      margin: 14px 0;
      user-select: none;
      touch-action: manipulation; /* ë”ë¸”íƒ­ í™•ëŒ€ ë°©ì§€ */
    }
    .btn {
      background: #333;
      border: 2px solid #555;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.4rem;
      color: #fff;
    }
    .btn:active { background: #555; }

    #start {
      padding: 8px 18px;
      border: none;
      border-radius: 6px;
      background: #4caf50;
      color: #fff;
      cursor: pointer;
      font-size: 1rem;
      margin-top: 8px;
    }

    @media (max-width: 480px) {
      :root { --cell: 22px; }
      .mini {
        grid-template-columns: repeat(4, 14px);
        grid-template-rows: repeat(4, 14px);
      }
      #controls {
        grid-template-columns: repeat(3, 50px);
        grid-template-rows: repeat(2, 50px);
      }
    }
  </style>
</head>
<body>
  <h1>ğŸ® Classic Tetris</h1>
  <button id="start">ê²Œì„ ì‹œì‘</button>

  <div id="wrapper">
    <div id="board"></div>

    <div id="side">
      <div class="panel"><h3>ë‹¤ìŒ</h3><div id="next" class="mini"></div></div>
      <div class="panel"><h3>ë³´ë¥˜</h3><div id="hold" class="mini"></div></div>
      <div class="panel"><h3>ì ìˆ˜</h3><div id="score">0</div></div>
      <div class="panel"><h3>ë ˆë²¨</h3><div id="level">1</div></div>
      <div class="panel"><h3>ì¤„</h3><div id="lines">0</div></div>
    </div>
  </div>

  <div id="controls">
    <div class="btn" id="left">â¬…ï¸</div>
    <div class="btn" id="rotate">ğŸ”„</div>
    <div class="btn" id="right">â¡ï¸</div>
    <div class="btn" style="grid-column:2/3" id="down">â¬‡ï¸</div>
    <div class="btn" style="grid-column:2/3" id="drop">ğŸ§¨</div>
    <div class="btn" id="holdBtn">â¸ï¸</div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const $ = id => document.getElementById(id);
    const rows = 20, cols = 10;
    const board = $('board');
    let grid = [], queue = [], current = null;
    let holdPiece = null, canHold = true;
    let playing = false;
    let score = 0, level = 1, lines = 0;
    const baseInterval = 700, lockDelay = 500;
    let timer, lockTimer = 0;

    const SHAPES = {
      T: [[1,cols,cols+1,cols+2],[1,cols+1,cols+2,cols*2+1],[cols,cols+1,cols+2,cols*2+1],[1,cols,cols+1,cols*2+1]],
      O: [[0,1,cols,cols+1]],
      I: [[1,cols+1,cols*2+1,cols*3+1],[cols,cols+1,cols+2,cols+3]],
      S: [[1,2,cols,cols+1],[0,cols,cols+1,cols*2]],
      Z: [[0,1,cols+1,cols+2],[2,cols,cols+1,cols*2+1]],
      L: [[0,cols,cols*2,cols*2+1],[cols,cols+1,cols+2,2],[0,1,cols+1,cols*2+1],[cols,cols*2,cols*2+1,cols*2+2]],
      J: [[1,cols+1,cols*2+1,cols*2],[0,1,2,cols+2],[1,cols+1,cols*2+1,cols*2+2],[0,cols,cols+1,cols+2]]
    };
    const COLORS = {T:'T',O:'O',I:'I',S:'S',Z:'Z',L:'L',J:'J'};
    Object.defineProperty(Object.prototype,'shape',{value(){return SHAPES[this.name][this.rot];},enumerable:false});

    /* ===== ê·¸ë¦¬ë“œ ìƒì„± ===== */
    function buildGrid(){
      board.style.gridTemplateColumns = `repeat(${cols},var(--cell))`;
      board.style.gridTemplateRows    = `repeat(${rows},var(--cell))`;
      board.innerHTML=''; grid=[];
      for(let i=0;i<rows*cols;i++){
        const d=document.createElement('div'); d.className='cell';
        board.appendChild(d); grid.push(d);
      }
    }

    /* ===== ë¯¸ë‹ˆ/ì ìˆ˜íŒ ===== */
    function drawMini(el,piece){
      el.innerHTML=''; const cells=[];
      for(let i=0;i<16;i++){const d=document.createElement('div');d.className='cell';el.appendChild(d);cells.push(d);}
      if(!piece) return;
      SHAPES[piece][0].forEach(i=>{
        const x=i%cols, y=Math.floor(i/cols);
        cells[y*4+x].classList.add(COLORS[piece]);
      });
    }
    const hud=()=>{ $('score').textContent=score; $('level').textContent=level; $('lines').textContent=lines; };

    /* ===== í & ìƒˆ ë¸”ë¡ ===== */
    const rnd=()=>Object.keys(SHAPES)[Math.floor(Math.random()*7)];
    function refill(){ while(queue.length<5) queue.push(rnd()); drawMini($('next'),queue[0]); }

    /* ===== ì¶©ëŒ/ê³ ìŠ¤íŠ¸/ê·¸ë¦¬ê¸° ===== */
    function hit(shape,off=0){
      return shape.some(i=>{
        const ni=current.pos+off+i,x=ni%cols,y=Math.floor(ni/cols);
        return x<0||x>=cols||y>=rows||grid[ni]?.classList.contains('frozen');
      });
    }
    const dropDist=()=>{let d=0; while(!hit(current.shape(),(d+1)*cols)) d++; return d;};
    const clearGhost=()=>grid.forEach(c=>c.classList.remove('ghost'));
    const drawCells=(idxs,cls,color)=>idxs.forEach(i=>grid[i]?.classList.add(cls,color));
    const eraseCells=(idxs,color)=>idxs.forEach(i=>grid[i]?.classList.remove('active',color));

    function placeGhost(){
      clearGhost();
      const d=dropDist();
      current.shape().forEach(i=>grid[current.pos+i+d*cols]?.classList.add('ghost'));
    }
    const drawCurr=()=>{drawCells(current.shape().map(i=>current.pos+i),'active',COLORS[current.name]);placeGhost();};
    const eraseCurr=()=>{eraseCells(current.shape().map(i=>current.pos+i),COLORS[current.name]);clearGhost();};

    /* ===== ê²Œì„ ì§„í–‰ ===== */
    function newPiece(){
      current={name:queue.shift(),pos:3,rot:0}; refill(); canHold=true;
      if(hit(current.shape())) return gameOver();
      drawCurr();
    }
    function lockPiece(){
      eraseCurr();
      current.shape().forEach(i=>grid[current.pos+i].classList.add('frozen',COLORS[current.name]));
      clearGhost(); delLines(); newPiece(); setGravity();
    }
    function delLines(){
      let cleared=0;
      for(let r=rows-1;r>=0;r--){
        if([...Array(cols)].every((_,c)=>grid[r*cols+c].classList.contains('frozen'))){
          cleared++;
          for(let c=0;c<cols;c++) grid[r*cols+c].className='cell';
          for(let rr=r;rr>0;rr--){
            for(let c=0;c<cols;c++){
              grid[rr*cols+c].className=grid[(rr-1)*cols+c].className;
            }
          }
          for(let c=0;c<cols;c++) grid[c].className='cell';
          r++;
        }
      }
      if(cleared){
        score += [0,100,300,500,800][cleared]*level;
        lines += cleared;
        if(lines>=level*10){level++; setGravity();}
        hud();
      }
    }

    /* ===== ì´ë™/íšŒì „ ===== */
    function move(dx,dy=0){
      eraseCurr();
      if(!hit(current.shape(),dx+dy*cols)){
        current.pos += dx+dy*cols;
        if(dy){score++; hud();}
        lockTimer=0;
      }
      drawCurr();
    }
    function rotate(){                 // ì‹œê³„ë°©í–¥ 90Â°
      eraseCurr();
      const nxt=(current.rot+1)%SHAPES[current.name].length; // +1 = CW
      for(const k of [0,-1,1,-2,2]){                       // ë²½í‚¥
        if(!hit(SHAPES[current.name][nxt],k)){
          current.rot=nxt; current.pos+=k; break;
        }
      }
      drawCurr();
    }
    const soft = ()=>move(0,1);
    function hard(){
      eraseCurr(); const d=dropDist();
      current.pos+=d*cols; score+=d*2; drawCurr(); lockPiece(); hud();
    }
    function hold(){
      if(!canHold) return;
      eraseCurr(); clearGhost();
      if(!holdPiece){ holdPiece=current.name; newPiece(); }
      else{ [holdPiece,current.name]=[current.name,holdPiece];
        current.pos=3; current.rot=0;
        if(hit(current.shape())) return gameOver();
        drawCurr();
      }
      canHold=false; drawMini($('hold'),holdPiece);
    }

    /* ===== ì¤‘ë ¥ ===== */
    function setGravity(){
      clearInterval(timer);
      timer=setInterval(()=>{
        if(!lockTimer) soft();
        else if(Date.now()-lockTimer>lockDelay) lockPiece();
      },Math.max(100,baseInterval-(level-1)*50));
    }

    /* ===== ì‹œì‘/ì¢…ë£Œ ===== */
    function startGame(){
      if(playing) return;
      playing=true;
      $('start').style.display='none';
      $('wrapper').style.display='flex';
      $('controls').style.display='grid';
      score=level=lines=0; hud();
      buildGrid(); queue=[]; refill();
      holdPiece=null; drawMini($('hold'),null);
      newPiece(); setGravity();
    }
    function gameOver(){
      clearInterval(timer);
      alert(`ê²Œì„ ì˜¤ë²„! ì´ ì ìˆ˜: ${score}`);
      playing=false;
      $('wrapper').style.display='none';
      $('controls').style.display='none';
      $('start').style.display='block';
    }

    $('start').onclick=startGame;

    /* ===== í‚¤ë³´ë“œ ===== */
    document.addEventListener('keydown',e=>{
      if(!playing) return;
      switch(e.key){
        case 'ArrowLeft': move(-1); break;
        case 'ArrowRight': move(1); break;
        case 'ArrowDown': soft(); break;
        case 'ArrowUp': rotate(); break;
        case ' ': e.preventDefault(); hard(); break;
        case 'c': case 'C': case 'Shift': hold(); break;
      }
    });

    /* ===== ë²„íŠ¼(ëª¨ë°”ì¼/ë°ìŠ¤í¬í†± ê³µí†µ) ===== */
    function bindButton(id, fn){
      const el=$(id); if(!el) return;
      el.addEventListener('pointerdown', e=>{
        e.preventDefault();           // 1íšŒë§Œ ì‹¤í–‰
        if(playing || id==='start') fn();
      }, {passive:false});
    }
    bindButton('left', ()=>move(-1));
    bindButton('right', ()=>move(1));
    bindButton('down', soft);
    bindButton('rotate', rotate);     // ğŸ”„ ë²„íŠ¼ â†’ 90Â° íšŒì „
    bindButton('drop', hard);
    bindButton('holdBtn', hold);
  });
  </script>
</body>
</html>
